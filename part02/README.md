# Part 02. 자료구조/알고리즘
## Table of Contents
| Part | Chapter | Subchapter |              Number             |                 Solution                  | Description |
| :--: | :-----: | :--------: | :-----------------------------: | :---------------------------------------: | :---------: |
|  02  |   01    |    09_1    | [01](./README.md#practice-0911) | [Java](./M0911.java)                      | 파스칼 삼각형 출력 |
|  02  |   01    |    09_1    | [02](./README.md#practice-0912) | [Java](./M0912.java)                      | 한자리 정수 배열, 현배열 다음으로 큰 수 구하기 (1스왑) |
|  02  |   01    |    09_1    | [03](./README.md#practice-0913) | [Java](./M0913.java)                      | String 1의 permutation이 String 2에 포함되는지 판별 |
|  02  |   01    |    09_1    | [04](./README.md#practice-0914) | [Java](./M0914.java)                      | 각 자리수를 제곱해서 더했을 때 1로 수렴하는지 판별 |
|  02  |   01    |    09_1    | [05](./README.md#practice-0915) | [Java](./M0915.java)                      | 해안선 길이 구하기 |
|  02  |   01    |    09_2    | [01](./README.md#practice-0921) | [Java](./M0921.java)                      | nth Catalan number |
|  02  |   01    |    09_2    | [02](./README.md#practice-0922) | [Java](./M0922.java)                      | palindrome / pseudopalindrome[^1] |
|  02  |   01    |    09_2    | [03](./README.md#practice-0923) | [Java](./M0923.java)                      | 1차 방정식 풀이 |
|  02  |   01    |    09_2    | [04](./README.md#practice-0924) | [Java](./M0924.java)                      | 짝수 인덱스에는 짝수, 홀수 인덱스에는 소수인 숫자 갯수 구하기 |
|  02  |   01    |    09_2    | [05](./README.md#practice-0925) | [Java](./M0925.java)                      | 하노이의 탑 |
|  02  |   02    |    14_1    | [01](./README.md#practice-1421) | [Java](./L1411.java)                      | 주어진 코드에 의해 변형된 배열을 원배열로 되돌리기 |
|  02  |   02    |    14_1    | [02](./README.md#practice-1412) | [Java](./L1412.java)                      | 2D 배열에서 0이 있는 행과 열을 0으로 변경 |
|  02  |   02    |    14_1    | [03](./README.md#practice-1413) | [Java](./L1413.java)                      | 풍선 터뜨리는 순서 |
|  02  |   02    |    14_1    | [04](./README.md#practice-1414) | [Java](./L1414.java)                      | 괄호 정상여부 판정 |
|  02  |   02    |    14_1    | [05](./README.md#practice-1415) | [Java](./L1415.java)                      | Snake 게임 종료시점 계산 |
|  02  |   02    |    14_2    | [01](./README.md#practice-1421) | [Java](./L1421.java)                      | 문서 중요도순 출력 |
|  02  |   02    |    14_2    | [02](./README.md#practice-1422) | [Java](./L1422.java)                      | stack으로 특정 수열 만들기 |
|  02  |   02    |    14_2    | [03](./README.md#practice-1423) | [Java](./L1423.java)                      | 장르카운트 > 고유카운트 > 고유번호 순서로 정렬 (장르별 2개씩) |
|  02  |   02    |    14_2    | [04](./README.md#practice-1424) | [Java](./L1424.java)                      | 참가자 배열 중 완주자 배열에 포함되지 않은 요소 구하기 (중복 가능) |
|  02  |   02    |    14_2    | [05](./README.md#practice-1425) | [Java](./L1425.java)                      | 배열상 요소를 한 종류씩 포함하는 최단 구간 |

[^1]: which becomes a palindrome after removing exactly one character.

## Chapter 01. 기초 수학
### [Practice 0911](./M0911.java)
파스칼의 삼각형(Pascal's triangle)은 수학에서 이항계수를 삼각형 모양의 기하학적 형태로 배열한 것이다.

파스칼의 삼각형은 다음과 같이 만들 수 있다.

1. 첫 번째 줄에는 숫자 1을 쓴다.
2. 그 다음 줄은 바로 위의 왼쪽 숫자와 오른쪽 숫자를 더한다.

![M0911.png](./M0911.png)

삼각형의 행의 수가 입력으로 주어졌을 때,  
파스칼의 삼각형을 출력하시오.


입출력 예시
---

|입력|출력|
|---|---|
|1|[[1]]|
|3|[[1], [1, 1], [1, 2, 1]]|
|5|[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]|


### [Practice 0912](./M0912.java)
양의 정수로 이루어진 arr 배열이 주어졌을 때  
해당 데이터로 만들 수 있는 permutation 중에서 다음과 같은 데이터를 출력하는 프로그램을 작성하세요.

- 현재 데이터보다 이전의 큰 수를 출력
- 한 번의 swap 으로 출력 가능한 큰 수를 출력


입출력 예시
---

|입력|출력|
|---|---|
|3, 2, 1|3, 1, 2|
|1, 9, 4, 7, 6|1, 9, 4, 6, 7|
|1, 1, 2, 3|1, 1, 2, 3|


### [Practice 0913](./M0913.java)
문자열 s1 과 s2 가 주어졌을 때,  
s1 을 permutation 한 문자열이 s2 의 부분 문자열에 해당하면 true 를 반환하고  
그렇지 않으면 false 를 반환하는 프로그램을 작성하세요.


입출력 예시
---

|s1|s2|출력|
|---|---|---|
|"ab"|"adbak"|true|
|"ac"|"car"|true|
|"ak"|"aabbkk"|false|


### [Practice 0914](./M0914.java)
주어진 양의 정수가 **행복한 수** 인지를 판별하는 프로그램을 작성하세요.

행복한 수란,  
각 자리수를 제곱한 것을 더하는 과정을 반복했을 때 1로 끝나는 수 이다. 
행복한 수가 아니라면 1에 도달하지 못하고 같은 수열이 반복하게 된다.

'행복한 수'를 찾는 과정 예시
  ```
  19 가 행복한 수인지 확인하는 과정
  1^2 + 9^2 = 82
  8^2 + 2^2 = 68
  6^2 + 8^2 = 100
  1^2 + 0^2 + 0^2 = 1
  ```

입출력 예시
---

|입력|출력|
|---|---|
|19|true|
|2|false|
|61|false|


### [Practice 0915](./M0915.java)
영토에 대한 지도 정보가 row x col grid 맵 형태로 다음과 같이 주어졌다.

이 때, grid[i][j] 가 1이 면 땅 영역을 의미하고  
grid[i][j] 가 0 이면 물 영역을 의미한다.

![M0915.png](./M0915.png)


이와 같이 영토에 대한 지도 정보가 주어졌을 때 땅의 둘레를 구하는 프로그램을 작성하세요.

- grid 한 cell 의 변의 길이는 1 이다.
- 지도에는 하나의 독립된 영토만 있다. (분리된 땅 없음)
- 땅 내부에 물이 존재하지 않는다.


입출력 예시
---

|입력|출력|
|---|---|
|{{1}}|4|
|{{0, 1, 0, 0}, {1, 1, 1, 0}, {0, 1, 0, 0}, {1, 1, 0, 0}}|16|


### [Practice 0921](./M0921.java)
카탈랑 수는 0번, 1번, 2번, ... 순으로 아래와 같이 구성되는 수열을 의미한다.
- 1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, … 

이를 점화식으로 나타내면 아래와 같다.

![M0921.png](./M0921.png)

카탈랑 수의 n 번째 값을 구하는 프로그램을 작성하세요.


입력 예시
---
|입력|출력|
|---|---|
|0|1|
|2|2|
|5|42|
|7|429|


### [Practice 0922](./M0922.java)
회문 또는 팰린드롬(palindrome)은 앞 뒤 방향으로 같은 순서의 문자로 구성된 문자열을 말한다.  
- 예시) ‘abba’ ‘kayak’, ‘madam’


<br/>

유사회문은 문자열 그 자체는 회문이 아니지만 한 문자를 삭제하면 회문이 되는 문자열을 말한다.  
- 예시) ‘summuus’의 5번째 또는 6번째 문자 ‘u’를 제거하면 ‘summus’인 회문을 만들 수 있다.

<br/>
주어진 문자열을 확인한 후 문자열 종류에 따라 다음과 같이 출력하는 프로그램을 작성하세요.

- 회문: 0
- 유사회문: 1
- 기타: 2


입력 예시
---
|입력|출력|
|---|---|
|abba|0|
|summuus|1|
|xabba|1|
|xabbay|2|
|comcom|2|
|comwwmoc|0|
|comwwtmoc|1|


### [Practice 0923](./M0923.java)
주어진 1차 방정식에 대해 풀이를 하는 프로그램을 작성하세요.

해당 방정식은 '+', '-', 'x' 와 '상수'로만 이루어져 있다.

해가 없으면 "No solution" 을 출력,  
해가 무한대인 경우 "Infinite solutions" 를 출력,  
해가 있는 경우 x의 값을 "x=" 형태로 출력 하세요.


입력 예시
---
|입력|출력|
|---|---|
|"x+5-3+x=6+x-2"|"x=2"|
|"x=x"|"Infinite solutions"|
|"2x=x"|"x=0"|


### [Practice 0924](./M0924.java)
아래와 같이 구성되는 좋은 수라고 한다.
* 짝수 인덱스 위치에는 짝수
* 홀수 인덱스 위치에는 소수 (2, 3, 5, 7)
* 인덱스는 0 부터 시작

```
예를 들면,
2582 는 좋은 수다.
- 짝수 인덱스 위치에는 짝수인 2와 8로, 홀수 위치에는 소수인 5와 2로 구성된다.

반면,
3245 는 좋은 수가 아니다.
- 짝수 인덱스 위치에 홀수인 3이 위치하고 있다.
```

1 이상의 정수 n이 주어졌을 때, n 자리로 구성될 수 있는 좋은 수의 개수를 출력하는 프로그램을 작성하세요.

단, n 의 값에 따라 값이 클 수 있으니 결과는 10^9 + 7로 나머지 연산을 한 결과로 출력하시오. 



입력 예시
---
|입력|출력|
|---|---|
|1|5|
|2|20|
|3|100|
|4|400|
|50|564908303|


### [Practice 0925](./M0925.java)
하노이의 탑은 퍼즐의 일종이다.

![M0925.png](./M0925.png)  
(Fig. 1. Tower of Hanoi from: wikipedia)

하노이의 탑 퍼즐 게임 규칙은 다음과 같다.
* 한 번에 한 개의 원판 만 옮길 수 있다.
* 큰 원판이 작은 원판 위에 있어서는 안된다.


원판의 개수 n 이 주어졌을 때  
가장 왼쪽 기둥으로부터 끝 기둥으로 이동하는 과정에 대해 출력하는 프로그램을 구현하세요.


입력 예시
---
|입력|출력|
|---|---|
|2|1 2 <br/> 1 3 <br/> 2 3|
|3|1 3 <br/> 1 2 <br/> 3 2 <br/> 1 3 <br/> 2 1 <br/> 2 3 <br/> 1 3|



# Chapter 2: 선형 자료구조
### [Practice 1411](./L1411.java)
과거에 하기의 modification 함수를 이용해 배열 내 데이터 순서를 변경했었다.

- 최근에 이 변경한 데이터들을 다시 원래의 배열 순서로 변경해야 하는 일이 생겼다.
- 아래의 modification 코드를 분석 후 되돌리는 코드를 작성하세요.


```java
public static int[] modification(int[] arr) {
        int[] arrNew = new int[arr.length];

        int idx = 0;
        int cnt = 0;
        int val = arr[idx];

        while (cnt < arr.length) {
            while (val == 0) {
                idx = (idx + 1) % arr.length;
                val = arr[idx];
            }
            arrNew[cnt++] = val;
            arr[idx] = 0;
            idx = (val + idx) % arr.length;
            val = arr[idx];
        }
        return arrNew;
    }
```

Modification 당시 입출력 샘플
---
|입력|출력|
|---|---|
|1 3 5 7 9|1 3 7 9 5|
|3 6 8 2|3 2 6 8|

되돌리기 입출력 예시
---
|입력|출력|
|---|---|
|1 3 7 9 5|1 3 5 7 9|
|3 2 6 8|3 6 8 2|


### [Practice 1412](./L1412.java)
정수로 이루어진 M x N 행렬 데이터가 있다고 하자.

- 행렬의 원소 중에 0이 있을 경우 해당 원소가 위치하는 행과 열 전체 데이터를 0으로 변경하는 코드를 작성하세요.


입출력 예시
---

![L1412.png](./L1412.png)


### [Practice 1413](./L1413.java)
1번부터 N번까지 N개의 풍선이 원형으로 놓여 있고. i번 풍선의 오른쪽에는 i+1번 풍선이 있고, 왼쪽에는 i-1번 풍선이 있다.  
단, 1번 풍선의 왼쪽에 N번 풍선이 있고, N번 풍선의 오른쪽에 1번 풍선이 있다.  
각 풍선 안에는 종이가 하나 들어있고, 종이에는 -N보다 크거나 같고, N보다 작거나 같은 정수가 하나 적혀있다.  
이 풍선들을 다음과 같은 규칙으로 터뜨린다.

우선, 제일 처음에는 1번 풍선을 터뜨린다.  
다음에는 풍선 안에 있는 종이를 꺼내어 그 종이에 적혀있는 값만큼 이동하여 다음 풍선을 터뜨린다.  
양수가 적혀 있을 경우에는 오른쪽으로, 음수가 적혀 있을 때는 왼쪽으로 이동한다.  
이동할 때에는 이미 터진 풍선은 빼고 이동한다.

예를 들어 다섯 개의 풍선 안에 차례로 3, 2, 1, -3, -1이 적혀 있었다고 하자.  
이 경우 3이 적혀 있는 1번 풍선, -3이 적혀 있는 4번 풍선, -1이 적혀 있는 5번 풍선, 1이 적혀 있는 3번 풍선, 2가 적혀 있는 2번 풍선의 순서대로 터지게 된다.


입력 예시
---
|입력|결과|
|---|---|
|3, 2, 1, -3, -1|1 4 5 3 2|
|3, 2, -1, -2|1 4 2 3|


### [Practice 1414](./L1414.java)
입력 문자열에서 괄호 짝 검사하여 이상이 없는지 판별하는 프로그램을 작성하세요.

- 괄호의 종류: (), {}, []
- 괄호 짝 이상이 없으면 Pass 출력
- 괄호 짝 이상이 있으면 Fail 출력
- 괄호 짝 이상 유무는 괄호를 열었으면 그에 대응되는 괄호로 닫혀 있는 것으로 판별한다.

입출력 예시
---
|입력 문자열|결과|
|---|---|
|"[yyyy]-[mm]-[dd]"|Pass|
|"System.out.println(arr[0][1))"|Fail|
|"Support [Java or Python(3.x)]"|Pass|


### [Practice 1415](./L1415.java)
'Dummy' 라는 도스게임이 있다. 이 게임에는 뱀이 나와서 기어다니는데, 사과를 먹으면 뱀 길이가 늘어난다. 뱀이 이리저리 기어다니다가 벽 또는 자기자신의 몸과 부딪히면 게임이 끝난다.

게임은 NxN 정사각 보드위에서 진행되고, 몇몇 칸에는 사과가 놓여져 있다. 보드의 상하좌우 끝에 벽이 있다. 게임이 시작할때 뱀은 맨위 맨좌측에 위치하고 뱀의 길이는 1 이다. 뱀은 처음에 오른쪽을 향한다.

뱀은 매 초마다 이동을 하는데 다음과 같은 규칙을 따른다.

- 먼저 뱀은 몸길이를 늘려 머리를 다음칸에 위치시킨다.
- 만약 이동한 칸에 사과가 있다면, 그 칸에 있던 사과가 없어지고 꼬리는 움직이지 않는다.
- 만약 이동한 칸에 사과가 없다면, 몸길이를 줄여서 꼬리가 위치한 칸을 비워준다. 즉, 몸길이는 변하지 않는다.
- 사과의 위치와 뱀의 이동경로가 주어질 때 이 게임이 몇 초에 끝나는지 계산하라.

- 입력
    - 보드의 크기 N (2 ≤ N ≤ 100)
    - 사과의 개수 K (0 ≤ K ≤ 100)
    - 뱀의 방향 변환 횟수 L (1 ≤ L ≤ 100)
    - 사과의 위치가 담긴 리스트 apples
        - 첫 번째 정수는 행, 두 번째 정수는 열 위치를 의미한다. 사과의 위치는 모두 다르며, 맨 위 맨 좌측 (1행 1열) 에는 사과가 없다.
    - 뱀의 방향 변환 정보 moves
        - 정수 X와 문자 C로 이루어져 있으며. 게임 시작 시간으로부터 X초가 끝난 뒤에 왼쪽(C가 'L') 또는 오른쪽(C가 'D')로 90도 방향을 회전시킨다는 뜻이다. X는 10,000 이하의 양의 정수이며, 방향 전환 정보는 X가 증가하는 순으로 주어진다.

입출력 예시
---
- 예시입력1
    - 입력
      ```python
      N = 6
      K = 3
      L = 3
      apples = [(3, 4), (2, 5), (5, 3)]
      moves = [(3, 'D'), (15, 'L'), (17, 'D')]
      ```
    - 출력: 9

- 예시입력2
    - 입력
      ```python
      N = 10
      K = 4
      L = 4
      apples = [(1, 2), (1, 3), (1, 4), (1, 5)]
      moves = [(8, 'D'), (10, 'D'), (11, 'D'), (13, 'L')]
      ```
    - 출력: 21

- 예시입력3
    - 입력
      ```python
      N = 10
      K = 5
      L = 4
      apples = [(1, 5), (1, 3), (1, 2), (1, 6), (1, 7)]
      moves = [(8, 'D'), (10, 'D'), (11, 'D'), (13, 'L')]
      ```
    - 출력: 13


### [Practice 1421](./L1421.java)
여러분도 알다시피 여러분의 프린터 기기는 여러분이 인쇄하고자 하는 문서를 인쇄 명령을 받은 ‘순서대로’,  
즉 먼저 요청된 것을 먼저 인쇄한다. 여러 개의 문서가 쌓인다면 Queue 자료구조에 쌓여서 FIFO - First In First Out - 에 따라 인쇄가 되게 된다.  
하지만 상근이는 새로운 프린터기 내부 소프트웨어를 개발하였는데, 이 프린터기는 다음과 같은 조건에 따라 인쇄를 하게 된다.

현재 Queue의 가장 앞에 있는 문서의 ‘중요도’를 확인한다.  
나머지 문서들 중 현재 문서보다 중요도가 높은 문서가 하나라도 있다면, 이 문서를 인쇄하지 않고 Queue의 가장 뒤에 재배치 한다.  
그렇지 않다면 바로 인쇄를 한다.
예를 들어 Queue에 4개의 문서(A B C D)가 있고, 중요도가 2 1 4 3 라면 C를 인쇄하고, 다음으로 D를 인쇄하고 A, B를 인쇄하게 된다.

현재 Queue에 있는 문서의 수와 중요도가 주어졌을 때, 어떤 한 문서가 몇 번째로 인쇄되는지 알아내는 코드를 작성하세요.  
예를 들어 위의 예에서 C문서는 1번째로, A문서는 3번째로 인쇄되게 된다.


입출력 예시
---
|문서 개수|출력 대상 번호|우선순위|출력|
|---|---|---|---|
|1|0|5|1|
|4|2|1 2 3 4|2|
|6|0|1 1 9 1 1 1|5|


### [Practice 1422](./L1422.java)
스택 (stack)은 기본적인 자료구조 중 하나로, 컴퓨터 프로그램을 작성할 때 자주 이용되는 개념이다.  
스택은 자료를 넣는 (push) 입구와 자료를 뽑는 (pop) 입구가 같다.  
제일 나중에 들어간 자료가 제일 먼저 나오는 (LIFO, Last in First out) 특성을 가지고 있다.

- 1부터 n까지의 수를 스택에 넣었다가 뽑아 늘어놓음으로써, 하나의 수열을 만들 수 있다.
- 이때, 스택에 push 하는 순서는 반드시 오름차순을 지키도록 한다고 하자.

임의의 수열이 주어졌을 때 스택을 이용해 그 수열을 만들 수 있는지 없는지,  
있다면 어떤 순서로 push와 pop 연산을 수행해야 하는지를 계산하는 프로그램을 작성하시오.  
같은 정수가 두 번 나오는 경우는 없다.


입출력 예시
---
|입력|결과|
|---|---|
|4 3 6 8 7 5 2 1|+ + + + - - + + - + + - - - - -|
|1 2 5 3 4|NO|


### [Practice 1423](./L1423.java)
스트리밍 사이트에서 장르 별로 가장 많이 재생된 노래를 두 개씩 모아 베스트 앨범을 출시하려 합니다.  
노래는 고유 번호로 구분하며, 노래를 수록하는 기준은 다음과 같습니다.

- 속한 노래가 많이 재생된 장르를 먼저 수록합니다.
- 장르 내에서 많이 재생된 노래를 먼저 수록합니다.
- 장르 내에서 재생 횟수가 같은 노래 중에서는 고유 번호가 낮은 노래를 먼저 수록합니다.

노래의 장르를 나타내는 문자열 배열 genres와 노래별 재생 횟수를 나타내는 정수 배열 plays가 주어질 때, 베스트 앨범에 들어갈 노래의 고유 번호를 순서대로 return 하도록 solution 함수를 완성하세요.

###제한사항
- genres[i]는 고유번호가 i인 노래의 장르입니다.
- plays[i]는 고유번호가 i인 노래가 재생된 횟수입니다.
- genres와 plays의 길이는 같으며, 이는 1 이상 10,000 이하입니다.
- 장르 종류는 100개 미만입니다.
- 장르에 속한 곡이 하나라면, 하나의 곡만 선택합니다.
- 모든 장르는 재생된 횟수가 다릅니다.

입출력 예시
---
|genres|plays|return|
|---|---|---|
|["classic", "pop", "classic", "classic", "pop"]|[500, 600, 150, 800, 2500]|[4, 1, 3, 0]|

* 입출력 예 설명 
  - classic 장르는 1,450회 재생되었으며, classic 노래는 다음과 같습니다.
    - 고유 번호 3: 800회 재생
    - 고유 번호 0: 500회 재생
    - 고유 번호 2: 150회 재생
  - pop 장르는 3,100회 재생되었으며, pop 노래는 다음과 같습니다.
    - 고유 번호 4: 2,500회 재생
    - 고유 번호 1: 600회 재생
  - 따라서 pop 장르의 [4, 1]번 노래를 먼저, classic 장르의 [3, 0]번 노래를 그다음에 수록합니다.


### [Practice 1424](./L1424.java)
수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.

마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.

- 제한사항
- 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.
- completion의 길이는 participant의 길이보다 1 작습니다.
- 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.
- 참가자 중에는 동명이인이 있을 수 있습니다.
  
입출력 예시
---
|participant|completion|return|
|-----|-------|------|
|["leo", "kiki", "eden"]|["eden", "kiki"]|"leo"|
|["marina", "josipa", "nikola", "vinko", "filipa"]| ["josipa", "filipa", "marina", "nikola"]|"vinko"|
|["mislav", "stanko", "mislav", "ana"]|["stanko", "ana", "mislav"]|"mislav"|

- 입출력 예에 대한 설명
  - 예제 1: "leo"는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.
  - 예제 2: "vinko"는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.
  - 예제 3: "mislav"는 참여자 명단에는 두 명이 있지만, 완주자 명단에는 한 명밖에 없기 때문에 한명은 완주하지 못했습니다.


### [Practice 1425](./L1425.java)
개발자 출신으로 세계 최고의 갑부가 된 어피치는 스트레스를 받을 때면 이를 풀기 위해 오프라인 매장에 쇼핑을 하러 가곤 합니다.
어피치는 쇼핑을 할 때면 매장 진열대의 특정 범위의 물건들을 모두 싹쓸이 구매하는 습관이 있습니다.
어느 날 스트레스를 풀기 위해 보석 매장에 쇼핑을 하러 간 어피치는 이전처럼 진열대의 특정 범위의 보석을 모두 구매하되 특별히 아래 목적을 달성하고 싶었습니다.

```
진열된 모든 종류의 보석을 적어도 1개 이상 포함하는 가장 짧은 구간을 찾아서 구매
```

예를 들어 아래 진열대는 4종류의 보석(RUBY, DIA, EMERALD, SAPPHIRE) 8개가 진열된 예시입니다.

|진열대 번호|1|2|3|4|5|6|7|8|
|---------|---|---|---|---|---|---|---|---|
|보석 이름|DIA|RUBY|RUBY|DIA|DIA|EMERALD|SAPPHIRE|DIA|

진열대의 3번부터 7번까지 5개의 보석을 구매하면 모든 종류의 보석을 적어도 하나 이상씩 포함하게 됩니다.

진열대의 3, 4, 6, 7번의 보석만 구매하는 것은 중간에 특정 구간(5번)이 빠지게 되므로 어피치의 쇼핑 습관에 맞지 않습니다.

진열대 번호 순서대로 보석들의 이름이 저장된 배열 gems가 매개변수로 주어집니다. 이때 모든 보석을 하나 이상 포함하는 가장 짧은 구간을 찾아서 return 하도록 solution 함수를 완성해주세요.
가장 짧은 구간의 시작 진열대 번호와 끝 진열대 번호를 차례대로 배열에 담아서 return 하도록 하며, 만약 가장 짧은 구간이 여러 개라면 시작 진열대 번호가 가장 작은 구간을 return 합니다.

- 제한사항
    - gems 배열의 크기는 1 이상 100,000 이하입니다.
    - gems 배열의 각 원소는 진열대에 나열된 보석을 나타냅니다.
    - gems 배열에는 1번 진열대부터 진열대 번호 순서대로 보석이름이 차례대로 저장되어 있습니다.
    - gems 배열의 각 원소는 길이가 1 이상 10 이하인 알파벳 대문자로만 구성된 문자열입니다.

입출력 예시
---

|gems|result|
|----|------|
|["DIA", "RUBY", "RUBY", "DIA", "DIA", "EMERALD", "SAPPHIRE", "DIA"]|[3, 7]|
|["AA", "AB", "AC", "AA", "AC"]|[1, 3]|
|["XYZ", "XYZ", "XYZ"]|[1, 1]|
|["ZZZ", "YYY", "NNNN", "YYY", "BBB"]|[1, 5]|

- 입출력 예에 대한 설명
    - 입출력 예 #1
        - 문제 예시와 같습니다.

    - 입출력 예 #2
        - 3종류의 보석(AA, AB, AC)을 모두 포함하는 가장 짧은 구간은 [1, 3], [2, 4]가 있습니다.
        - 시작 진열대 번호가 더 작은 [1, 3]을 return 해주어야 합니다.

    - 입출력 예 #3
        - 1종류의 보석(XYZ)을 포함하는 가장 짧은 구간은 [1, 1], [2, 2], [3, 3]이 있습니다.
        - 시작 진열대 번호가 가장 작은 [1, 1]을 return 해주어야 합니다.

    - 입출력 예 #4
        - 4종류의 보석(ZZZ, YYY, NNNN, BBB)을 모두 포함하는 구간은 [1, 5]가 유일합니다.
        - 그러므로 [1, 5]를 return 해주어야 합니다.


# Chatper 3: 비선형 자료구조

# Chapter 4: 알고리즘
